{"ast":null,"code":"var _jsxFileName = \"/Users/niles/Desktop/Github/cmaj/firstProj/gui/src/3D/Sphere.js\",\n  _s = $RefreshSig$();\nimport { useRef } from 'react';\nimport { Color, AdditiveBlending } from 'three';\nimport { Canvas, extend, useFrame } from '@react-three/fiber';\nimport { OrbitControls, Sparkles, shaderMaterial, useGLTF, useTexture } from '@react-three/drei';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Model(props) {\n  _s();\n  const portalMaterial = useRef();\n  useFrame((state, delta) => portalMaterial.current.uTime += delta);\n  return (\n    /*#__PURE__*/\n    // <group {...props} dispose={null}>\n    //   <mesh geometry={nodes.portalCircle.geometry} position={[0, 0.78, 1.6]} rotation={[-Math.PI / 2, 0, 0]}>\n    //     <portalMaterial ref={portalMaterial} blending={AdditiveBlending} uColorStart=\"hotpink\" uColorEnd=\"white\" />\n    //   </mesh>\n    //   <mesh geometry={nodes.lampLightL.geometry} material-color=\"#f0bf94\" position={[0.89, 1.07, -0.14]} scale={[0.07, 0.11, 0.07]} />\n    //   <mesh geometry={nodes.lampLightR.geometry} material-color=\"#f0bf94\" position={[-0.98, 1.07, -0.14]} scale={[-0.07, 0.11, 0.07]} />\n    //   <mesh geometry={nodes.baked.geometry} position={[0.9, 0.34, -1.47]} rotation={[0, 0.14, 0]}>\n    //     <meshBasicMaterial map={bakedTexture} map-flipY={false} />\n    //   </mesh>\n    // </group>\n    _jsxDEV(\"mesh\", {\n      castShadow: true,\n      receiveShadow: true,\n      ref: mat,\n      position: [0, 0, 0],\n      children: [/*#__PURE__*/_jsxDEV(\"sphereGeometry\", {\n        attach: \"geometry\",\n        args: [1.8, 128, 128]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 27,\n        columnNumber: 5\n      }, this), /*#__PURE__*/_jsxDEV(\"meshPhysicalMaterial\", {\n        attach: \"material\",\n        color: props.loaded ? \"#444444\" : \"#999999\",\n        metalness: 0.0,\n        roughness: 0.3,\n        castShadow: true\n        // flatShading={true}\n        ,\n        onBeforeCompile: oBC\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 28,\n        columnNumber: 5\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 5\n    }, this)\n  );\n}\n_s(Model, \"o7E3IC9nNLQLfCbJbaqzt8lcL3w=\", false, function () {\n  return [useFrame];\n});\n_c = Model;\nconst PortalMaterial = shaderMaterial({\n  uTime: 0,\n  uColorStart: new Color('hotpink'),\n  uColorEnd: new Color('white')\n}, \"\\n  varying vec2 vUv;\\n  void main() {\\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\\n    vec4 viewPosition = viewMatrix * modelPosition;\\n    vec4 projectionPosition = projectionMatrix * viewPosition;\\n    gl_Position = projectionPosition;\\n    vUv = uv;\\n  }\", \"\\n  //\\n// GLSL textureless classic 3D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-10-11\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_136565089(vec3 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289_136565089(vec4 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute_136565089(vec4 x)\\n{\\n  return mod289_136565089(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt_136565089(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nvec3 fade_136565089(vec3 t) {\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\\n\\n// Classic Perlin noise\\nfloat cnoise3(vec3 P)\\n{\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod289_136565089(Pi0);\\n  Pi1 = mod289_136565089(Pi1);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute_136565089(permute_136565089(ix) + iy);\\n  vec4 ixy0 = permute_136565089(ixy + iz0);\\n  vec4 ixy1 = permute_136565089(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt_136565089(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt_136565089(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade_136565089(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n  return 2.2 * n_xyz;\\n}\\n\\n  uniform float uTime;\\n  uniform vec3 uColorStart;\\n  uniform vec3 uColorEnd;\\n  varying vec2 vUv;\\n  void main() {\\n    vec2 displacedUv = vUv + cnoise3(vec3(vUv * 7.0, uTime * 0.1));\\n    float strength = cnoise3(vec3(displacedUv * 5.0, uTime * 0.2));\\n    float outerGlow = distance(vUv, vec2(0.5)) * 4.0 - 1.4;\\n    strength += outerGlow;\\n    strength += step(-0.2, strength) * 0.8;\\n    strength = clamp(strength, 0.0, 1.0);\\n    vec3 color = mix(uColorStart, uColorEnd, strength);\\n    gl_FragColor = vec4(color, 1.0);\\n    #include <tonemapping_fragment>\\n    #include <encodings_fragment>\\n  }\");\n\n// shaderMaterial creates a THREE.ShaderMaterial, and auto-creates uniform setter/getters\n// extend makes it available in JSX, in this case <portalMaterial />\nextend({\n  PortalMaterial\n});\nvar _c;\n$RefreshReg$(_c, \"Model\");","map":{"version":3,"names":["useRef","Color","AdditiveBlending","Canvas","extend","useFrame","OrbitControls","Sparkles","shaderMaterial","useGLTF","useTexture","jsxDEV","_jsxDEV","Model","props","_s","portalMaterial","state","delta","current","uTime","castShadow","receiveShadow","ref","mat","position","children","attach","args","fileName","_jsxFileName","lineNumber","columnNumber","color","loaded","metalness","roughness","onBeforeCompile","oBC","_c","PortalMaterial","uColorStart","uColorEnd","$RefreshReg$"],"sources":["/Users/niles/Desktop/Github/cmaj/firstProj/gui/src/3D/Sphere.js"],"sourcesContent":["import { useRef } from 'react'\nimport { Color, AdditiveBlending } from 'three'\nimport { Canvas, extend, useFrame } from '@react-three/fiber'\nimport { OrbitControls, Sparkles, shaderMaterial, useGLTF, useTexture } from '@react-three/drei'\nimport glsl from 'babel-plugin-glsl/macro'\n\nexport default function Model(props) {\n  const portalMaterial = useRef()\n  useFrame((state, delta) => (portalMaterial.current.uTime += delta))\n  return (\n    // <group {...props} dispose={null}>\n    //   <mesh geometry={nodes.portalCircle.geometry} position={[0, 0.78, 1.6]} rotation={[-Math.PI / 2, 0, 0]}>\n    //     <portalMaterial ref={portalMaterial} blending={AdditiveBlending} uColorStart=\"hotpink\" uColorEnd=\"white\" />\n    //   </mesh>\n    //   <mesh geometry={nodes.lampLightL.geometry} material-color=\"#f0bf94\" position={[0.89, 1.07, -0.14]} scale={[0.07, 0.11, 0.07]} />\n    //   <mesh geometry={nodes.lampLightR.geometry} material-color=\"#f0bf94\" position={[-0.98, 1.07, -0.14]} scale={[-0.07, 0.11, 0.07]} />\n    //   <mesh geometry={nodes.baked.geometry} position={[0.9, 0.34, -1.47]} rotation={[0, 0.14, 0]}>\n    //     <meshBasicMaterial map={bakedTexture} map-flipY={false} />\n    //   </mesh>\n    // </group>\n    <mesh \n    castShadow\n    receiveShadow\n    ref={mat}\n    position={[0,0,0]}\n  >\n    <sphereGeometry attach=\"geometry\" args={[1.8, 128, 128]} />\n    <meshPhysicalMaterial \n      attach=\"material\"\n      color={props.loaded?\"#444444\":\"#999999\"}\n      metalness={0.0}\n      roughness={0.3}\n      castShadow\n      // flatShading={true}\n      onBeforeCompile={oBC}\n    />\n  </mesh>\n  )\n}\n\nconst PortalMaterial = shaderMaterial(\n  { uTime: 0, uColorStart: new Color('hotpink'), uColorEnd: new Color('white') },\n  glsl`\n  varying vec2 vUv;\n  void main() {\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n    vec4 viewPosition = viewMatrix * modelPosition;\n    vec4 projectionPosition = projectionMatrix * viewPosition;\n    gl_Position = projectionPosition;\n    vUv = uv;\n  }`,\n  glsl`\n  #pragma glslify: cnoise3 = require(glsl-noise/classic/3d.glsl) \n  uniform float uTime;\n  uniform vec3 uColorStart;\n  uniform vec3 uColorEnd;\n  varying vec2 vUv;\n  void main() {\n    vec2 displacedUv = vUv + cnoise3(vec3(vUv * 7.0, uTime * 0.1));\n    float strength = cnoise3(vec3(displacedUv * 5.0, uTime * 0.2));\n    float outerGlow = distance(vUv, vec2(0.5)) * 4.0 - 1.4;\n    strength += outerGlow;\n    strength += step(-0.2, strength) * 0.8;\n    strength = clamp(strength, 0.0, 1.0);\n    vec3 color = mix(uColorStart, uColorEnd, strength);\n    gl_FragColor = vec4(color, 1.0);\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n  }`,\n)\n\n// shaderMaterial creates a THREE.ShaderMaterial, and auto-creates uniform setter/getters\n// extend makes it available in JSX, in this case <portalMaterial />\nextend({ PortalMaterial })\n"],"mappings":";;AAAA,SAASA,MAAM,QAAQ,OAAO;AAC9B,SAASC,KAAK,EAAEC,gBAAgB,QAAQ,OAAO;AAC/C,SAASC,MAAM,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,oBAAoB;AAC7D,SAASC,aAAa,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,OAAO,EAAEC,UAAU,QAAQ,mBAAmB;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAGhG,eAAe,SAASC,KAAKA,CAACC,KAAK,EAAE;EAAAC,EAAA;EACnC,MAAMC,cAAc,GAAGhB,MAAM,CAAC,CAAC;EAC/BK,QAAQ,CAAC,CAACY,KAAK,EAAEC,KAAK,KAAMF,cAAc,CAACG,OAAO,CAACC,KAAK,IAAIF,KAAM,CAAC;EACnE;IAAA;IACE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAN,OAAA;MACAS,UAAU;MACVC,aAAa;MACbC,GAAG,EAAEC,GAAI;MACTC,QAAQ,EAAE,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAE;MAAAC,QAAA,gBAElBd,OAAA;QAAgBe,MAAM,EAAC,UAAU;QAACC,IAAI,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG;MAAE;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eAC3DpB,OAAA;QACEe,MAAM,EAAC,UAAU;QACjBM,KAAK,EAAEnB,KAAK,CAACoB,MAAM,GAAC,SAAS,GAAC,SAAU;QACxCC,SAAS,EAAE,GAAI;QACfC,SAAS,EAAE,GAAI;QACff,UAAU;QACV;QAAA;QACAgB,eAAe,EAAEC;MAAI;QAAAT,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACtB,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACE;EAAC;AAET;AAACjB,EAAA,CAhCuBF,KAAK;EAAA,QAE3BR,QAAQ;AAAA;AAAAkC,EAAA,GAFc1B,KAAK;AAkC7B,MAAM2B,cAAc,GAAGhC,cAAc,CACnC;EAAEY,KAAK,EAAE,CAAC;EAAEqB,WAAW,EAAE,IAAIxC,KAAK,CAAC,SAAS,CAAC;EAAEyC,SAAS,EAAE,IAAIzC,KAAK,CAAC,OAAO;AAAE,CAAC,isIA4BhF,CAAC;;AAED;AACA;AACAG,MAAM,CAAC;EAAEoC;AAAe,CAAC,CAAC;AAAA,IAAAD,EAAA;AAAAI,YAAA,CAAAJ,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}