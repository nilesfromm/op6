{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { strToU8, zipSync } from \"fflate\";\nimport { Mesh, MeshPhysicalMaterial } from \"three\";\nclass USDZExporter {\n  constructor() {\n    __publicField(this, \"PRECISION\", 7);\n    __publicField(this, \"materials\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"files\");\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n  async parse(scene) {\n    const modelFileName = \"model.usda\";\n    this.files[modelFileName] = null;\n    let output = this.buildHeader();\n    scene.traverseVisible(object => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n        const geometryFileName = \"geometries/Geometry_\" + geometry.id + \".usd\";\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry);\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);\n        }\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material;\n        }\n        output += this.buildXform(object, geometry, material);\n      }\n    });\n    output += this.buildMaterials(this.materials);\n    this.files[modelFileName] = strToU8(output);\n    output = null;\n    for (const id in this.textures) {\n      const texture = this.textures[id];\n      const color = id.split(\"_\")[1];\n      const isRGBA = texture.format === 1023;\n      const canvas = this.imageToCanvas(texture.image, color);\n      const blob = await new Promise(resolve => canvas == null ? void 0 : canvas.toBlob(resolve, isRGBA ? \"image/png\" : \"image/jpeg\", 1));\n      if (blob) {\n        this.files[\"textures/Texture_\".concat(id, \".\").concat(isRGBA ? \"png\" : \"jpg\")] = new Uint8Array(await blob.arrayBuffer());\n      }\n    }\n    let offset = 0;\n    for (const filename in this.files) {\n      const file = this.files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        this.files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n      if (file && typeof file.length === \"number\") {\n        offset = file.length;\n      }\n    }\n    return zipSync(this.files, {\n      level: 0\n    });\n  }\n  imageToCanvas(image, color) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== \"undefined\" && image instanceof OffscreenCanvas || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n      const scale = 1024 / Math.max(image.width, image.height);\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = image.width * Math.min(1, scale);\n      canvas.height = image.height * Math.min(1, scale);\n      const context = canvas.getContext(\"2d\");\n      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n      if (color !== void 0) {\n        const hex = parseInt(color, 16);\n        const r = (hex >> 16 & 255) / 255;\n        const g = (hex >> 8 & 255) / 255;\n        const b = (hex & 255) / 255;\n        const imagedata = context == null ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n        if (imagedata) {\n          const data = imagedata == null ? void 0 : imagedata.data;\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r;\n            data[i + 1] = data[i + 1] * g;\n            data[i + 2] = data[i + 2] * b;\n          }\n          context == null ? void 0 : context.putImageData(imagedata, 0, 0);\n        }\n      }\n      return canvas;\n    }\n  }\n  buildHeader() {\n    return \"#usda 1.0\\n(\\n    customLayerData = {\\n        string creator = \\\"Three.js USDZExporter\\\"\\n    }\\n    metersPerUnit = 1\\n    upAxis = \\\"Y\\\"\\n)\\n\";\n  }\n  buildUSDFileAsString(dataToInsert) {\n    let output = this.buildHeader();\n    output += dataToInsert;\n    return strToU8(output);\n  }\n  // Xform\n  buildXform(object, geometry, material) {\n    const name = \"Object_\" + object.id;\n    const transform = this.buildMatrix(object.matrixWorld);\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn(\"THREE.USDZExporter: USDZ does not support negative scales\", object);\n    }\n    return \"def Xform \\\"\".concat(name, \"\\\" (\\n    prepend references = @./geometries/Geometry_\").concat(geometry.id, \".usd@</Geometry>\\n)\\n{\\n    matrix4d xformOp:transform = \").concat(transform, \"\\n    uniform token[] xformOpOrder = [\\\"xformOp:transform\\\"]\\n    rel material:binding = </Materials/Material_\").concat(material.id, \">\\n}\\n\");\n  }\n  buildMatrix(matrix) {\n    const array = matrix.elements;\n    return \"( \".concat(this.buildMatrixRow(array, 0), \", \").concat(this.buildMatrixRow(array, 4), \", \").concat(this.buildMatrixRow(array, 8), \", \").concat(this.buildMatrixRow(array, 12), \" )\");\n  }\n  buildMatrixRow(array, offset) {\n    return \"(\".concat(array[offset + 0], \", \").concat(array[offset + 1], \", \").concat(array[offset + 2], \", \").concat(array[offset + 3], \")\");\n  }\n  // Mesh\n  buildMeshObject(geometry) {\n    const mesh = this.buildMesh(geometry);\n    return \"\\ndef \\\"Geometry\\\"\\n{\\n  \".concat(mesh, \"\\n}\\n\");\n  }\n  buildMesh(geometry) {\n    const name = \"Geometry\";\n    const attributes = geometry.attributes;\n    const count = attributes.position.count;\n    return \"\\n    def Mesh \\\"\".concat(name, \"\\\"\\n    {\\n        int[] faceVertexCounts = [\").concat(this.buildMeshVertexCount(geometry), \"]\\n        int[] faceVertexIndices = [\").concat(this.buildMeshVertexIndices(geometry), \"]\\n        normal3f[] normals = [\").concat(this.buildVector3Array(attributes.normal, count), \"] (\\n            interpolation = \\\"vertex\\\"\\n        )\\n        point3f[] points = [\").concat(this.buildVector3Array(attributes.position, count), \"]\\n        float2[] primvars:st = [\").concat(this.buildVector2Array(attributes.uv, count), \"] (\\n            interpolation = \\\"vertex\\\"\\n        )\\n        uniform token subdivisionScheme = \\\"none\\\"\\n    }\\n\");\n  }\n  buildMeshVertexCount(geometry) {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n    return Array(count / 3).fill(3).join(\", \");\n  }\n  buildMeshVertexIndices(geometry) {\n    if (geometry.index !== null) {\n      return geometry.index.array.join(\", \");\n    }\n    const array = [];\n    const length = geometry.attributes.position.count;\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n    return array.join(\", \");\n  }\n  buildVector3Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: Normals missing.\");\n      return Array(count).fill(\"(0, 0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(\"(\".concat(data[i + 0].toPrecision(this.PRECISION), \", \").concat(data[i + 1].toPrecision(this.PRECISION), \", \").concat(data[i + 2].toPrecision(this.PRECISION), \")\"));\n    }\n    return array.join(\", \");\n  }\n  buildVector2Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: UVs missing.\");\n      return Array(count).fill(\"(0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 2) {\n      array.push(\"(\".concat(data[i + 0].toPrecision(this.PRECISION), \", \").concat(1 - data[i + 1].toPrecision(this.PRECISION), \")\"));\n    }\n    return array.join(\", \");\n  }\n  // Materials\n  buildMaterials(materials) {\n    const array = [];\n    for (const uuid in materials) {\n      const material = materials[uuid];\n      array.push(this.buildMaterial(material));\n    }\n    return \"def \\\"Materials\\\"\\n{\\n\".concat(array.join(\"\"), \"\\n}\\n\");\n  }\n  buildMaterial(material) {\n    const pad = \"            \";\n    const inputs = [];\n    const samplers = [];\n    if (material.map !== null) {\n      inputs.push(\"\".concat(pad, \"color3f inputs:diffuseColor.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.map.id, \"_diffuse.outputs:rgb>\"));\n      if (material.transparent || material.alphaTest > 0) {\n        inputs.push(\"\".concat(pad, \"float inputs:opacity.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.map.id, \"_diffuse.outputs:a>\"));\n      }\n      if (material.alphaTest > 0.01) {\n        inputs.push(\"\".concat(pad, \"float inputs:opacityThreshold = \").concat(material.alphaTest));\n      } else if (material.transparent || material.alphaTest > 0) {\n        inputs.push(\"\".concat(pad, \"float inputs:opacityThreshold = 0.01\"));\n      }\n      samplers.push(this.buildTexture(material, material.map, \"diffuse\", material.color));\n    } else {\n      inputs.push(\"\".concat(pad, \"color3f inputs:diffuseColor = \").concat(this.buildColor(material.color)));\n    }\n    if (material.emissiveMap !== null) {\n      inputs.push(\"\".concat(pad, \"color3f inputs:emissiveColor.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.emissiveMap.id, \"_emissive.outputs:rgb>\"));\n      samplers.push(this.buildTexture(material, material.emissiveMap, \"emissive\"));\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(\"\".concat(pad, \"color3f inputs:emissiveColor = \").concat(this.buildColor(material.emissive)));\n    }\n    if (material.normalMap !== null) {\n      inputs.push(\"\".concat(pad, \"normal3f inputs:normal.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.normalMap.id, \"_normal.outputs:rgb>\"));\n      samplers.push(this.buildTexture(material, material.normalMap, \"normal\"));\n    }\n    if (material.aoMap !== null) {\n      inputs.push(\"\".concat(pad, \"float inputs:occlusion.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.aoMap.id, \"_occlusion.outputs:r>\"));\n      samplers.push(this.buildTexture(material, material.aoMap, \"occlusion\"));\n    }\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(\"\".concat(pad, \"float inputs:roughness.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.roughnessMap.id, \"_roughness.outputs:g>\"));\n      samplers.push(this.buildTexture(material, material.roughnessMap, \"roughness\"));\n    } else {\n      inputs.push(\"\".concat(pad, \"float inputs:roughness = \").concat(material.roughness));\n    }\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(\"\".concat(pad, \"float inputs:metallic.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.metalnessMap.id, \"_metallic.outputs:b>\"));\n      samplers.push(this.buildTexture(material, material.metalnessMap, \"metallic\"));\n    } else {\n      inputs.push(\"\".concat(pad, \"float inputs:metallic = \").concat(material.metalness));\n    }\n    inputs.push(\"\".concat(pad, \"float inputs:opacity = \").concat(material.opacity));\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(\"\".concat(pad, \"float inputs:clearcoat = \").concat(material.clearcoat));\n      inputs.push(\"\".concat(pad, \"float inputs:clearcoatRoughness = \").concat(material.clearcoatRoughness));\n      inputs.push(\"\".concat(pad, \"float inputs:ior = \").concat(material.ior));\n    }\n    return \"\\n    def Material \\\"Material_\".concat(material.id, \"\\\"\\n    {\\n        def Shader \\\"PreviewSurface\\\"\\n        {\\n            uniform token info:id = \\\"UsdPreviewSurface\\\"\\n\").concat(inputs.join(\"\\n\"), \"\\n            int inputs:useSpecularWorkflow = 0\\n            token outputs:surface\\n        }\\n        token outputs:surface.connect = </Materials/Material_\").concat(material.id, \"/PreviewSurface.outputs:surface>\\n        token inputs:frame:stPrimvarName = \\\"st\\\"\\n        def Shader \\\"uvReader_st\\\"\\n        {\\n            uniform token info:id = \\\"UsdPrimvarReader_float2\\\"\\n            token inputs:varname.connect = </Materials/Material_\").concat(material.id, \".inputs:frame:stPrimvarName>\\n            float2 inputs:fallback = (0.0, 0.0)\\n            float2 outputs:result\\n        }\\n\").concat(samplers.join(\"\\n\"), \"\\n    }\\n\");\n  }\n  buildTexture(material, texture, mapType, color) {\n    const id = texture.id + (color ? \"_\" + color.getHexString() : \"\");\n    const isRGBA = texture.format === 1023;\n    this.textures[id] = texture;\n    return \"\\n      def Shader \\\"Transform2d_\".concat(mapType, \"\\\" (\\n          sdrMetadata = {\\n              string role = \\\"math\\\"\\n          }\\n      )\\n      {\\n          uniform token info:id = \\\"UsdTransform2d\\\"\\n          float2 inputs:in.connect = </Materials/Material_\").concat(material.id, \"/uvReader_st.outputs:result>\\n          float2 inputs:scale = \").concat(this.buildVector2(texture.repeat), \"\\n          float2 inputs:translation = \").concat(this.buildVector2(texture.offset), \"\\n          float2 outputs:result\\n      }\\n      def Shader \\\"Texture_\").concat(texture.id, \"_\").concat(mapType, \"\\\"\\n      {\\n          uniform token info:id = \\\"UsdUVTexture\\\"\\n          asset inputs:file = @textures/Texture_\").concat(id, \".\").concat(isRGBA ? \"png\" : \"jpg\", \"@\\n          float2 inputs:st.connect = </Materials/Material_\").concat(material.id, \"/Transform2d_\").concat(mapType, \".outputs:result>\\n          token inputs:wrapS = \\\"repeat\\\"\\n          token inputs:wrapT = \\\"repeat\\\"\\n          float outputs:r\\n          float outputs:g\\n          float outputs:b\\n          float3 outputs:rgb\\n          \").concat(material.transparent || material.alphaTest > 0 ? \"float outputs:a\" : \"\", \"\\n      }\");\n  }\n  buildColor(color) {\n    return \"(\".concat(color.r, \", \").concat(color.g, \", \").concat(color.b, \")\");\n  }\n  buildVector2(vector) {\n    return \"(\".concat(vector.x, \", \").concat(vector.y, \")\");\n  }\n}\nexport { USDZExporter };\n//# sourceMappingURL=USDZExporter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}