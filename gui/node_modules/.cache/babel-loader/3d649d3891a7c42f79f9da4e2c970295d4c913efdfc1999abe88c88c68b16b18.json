{"ast":null,"code":"import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst checkIfFrameIsEmpty = frameData => {\n  for (let i = 3; i < frameData.length; i += 4) {\n    if (frameData[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  const v = useThree(state => state.viewport);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(resolve => {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        totalFrames.current = numberOfFrames;\n        const {\n          rows,\n          columns,\n          frameWidth,\n          frameHeight,\n          emptyFrames\n        } = getRowsAndColumns(_spriteTexture, numberOfFrames);\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            rows,\n            columns,\n            frameWidth,\n            frameHeight,\n            scale: '1'\n          }\n        };\n        for (let row = 0; row < rows; row++) {\n          for (let col = 0; col < columns; col++) {\n            const isExcluded = (emptyFrames !== null && emptyFrames !== void 0 ? emptyFrames : []).some(coord => coord.row === row && coord.col === col);\n            if (isExcluded) {\n              continue;\n            }\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: col * frameWidth,\n                y: row * frameHeight,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: frameHeight\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n\n      //scale ratio for stadalone sprite\n      spriteDataRef.current.frames = calculateScaleRatio(spriteDataRef.current.frames);\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = THREE.SRGBColorSpace;\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n  const getRowsAndColumns = (texture, totalFrames) => {\n    if (texture.image) {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      canvas.width = texture.image.width;\n      canvas.height = texture.image.height;\n      ctx.drawImage(texture.image, 0, 0);\n      const width = texture.image.width;\n      const height = texture.image.height;\n\n      // Calculate rows and columns based on the number of frames and image dimensions\n      const cols = Math.round(Math.sqrt(totalFrames * (width / height)));\n      const rows = Math.round(totalFrames / cols);\n      const frameWidth = width / cols;\n      const frameHeight = height / rows;\n      const emptyFrames = [];\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const frameIndex = row * cols + col;\n          if (frameIndex >= totalFrames) {\n            emptyFrames.push({\n              row,\n              col\n            });\n            continue;\n          }\n          const frameData = ctx.getImageData(col * frameWidth, row * frameHeight, frameWidth, frameHeight).data;\n          const isEmpty = checkIfFrameIsEmpty(frameData);\n          if (isEmpty) {\n            emptyFrames.push({\n              row,\n              col\n            });\n          }\n        }\n      }\n      return {\n        rows,\n        columns: cols,\n        frameWidth,\n        frameHeight,\n        emptyFrames\n      };\n    } else {\n      return {\n        rows: 0,\n        columns: 0,\n        frameWidth: 0,\n        frameHeight: 0,\n        emptyFrames: []\n      };\n    }\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const value of data['frames']) {\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (const frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (const frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      let spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      spritesArr = calculateScaleRatio(spritesArr);\n      return spritesArr;\n    }\n  };\n\n  // calculate scale ratio for the frames\n  const calculateScaleRatio = frames => {\n    // Find the largest frame\n    let largestFrame = null;\n    for (const frame of frames) {\n      const {\n        w,\n        h\n      } = frame.frame;\n      const area = w * h;\n      if (!largestFrame || area > largestFrame.area) {\n        largestFrame = {\n          ...frame.frame,\n          area\n        };\n      }\n    }\n\n    // Set scaleRatio property on each frame\n    for (const frame of frames) {\n      var _largestFrame;\n      const {\n        w,\n        h\n      } = frame.frame;\n      const area = w * h;\n      if (area === ((_largestFrame = largestFrame) == null ? void 0 : _largestFrame.area)) {\n        frame.scaleRatio = 1;\n      } else {\n        var _largestFrame2;\n        frame.scaleRatio = Math.sqrt(area / ((_largestFrame2 = largestFrame) == null ? void 0 : _largestFrame2.area));\n      }\n    }\n    return frames;\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\nexport { calculateAspectRatio, checkIfFrameIsEmpty, getFirstItem, useSpriteLoader };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}